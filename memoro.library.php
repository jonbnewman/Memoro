<?php/** * Memoro * An experimental bare-bones PDO based ORM incorporating integrated caching with deep record expiration support. */namespace Memoro;// nextType define'sdefine( __NAMESPACE__ . '\OPERATOR', 1 );define( __NAMESPACE__ . '\VALUE',    2 );class DB {  public static $ref = array(    'config' => array(      'database' => array(        'type'     => 'mysql',        'host'     => 'localhost',        'database' => 'database',        'username' => 'username',        'password' => 'password' ),      'cache' => array(        'enabled'  => true,        'type'     => 'redis',        'options' => array(          'host'     => 'localhost',          'database' => 10        )      )    ),    // internal table definitions, used for lookup in case the full definition is not supplied upon initialization    'tables' => array(      'pages' => array(         'table'      => 'category_item',        'primaryKey' => 'category_item_id',        'fields'     => array( 'label', 'sizes', 'price', 'sort_order', 'category_id' ),      )    ),        'handler' => array(      'sql'   => false,      'cache' => false    )  );    public function init( $options = false ) {    if( !empty( $options['config'] ) ) {      DB::$ref['config'] = $options['config'];    }        if( !empty( $options['tables'] ) ) {      DB::$ref['tables'] = $options['tables'];    }    // initialize cache handler if needed/desired    if( $options['config']['cache']['enabled'] ) {      switch( $options['config']['cache']['type'] ) {        case 'redis':          // connect to redis          try {            DB::$ref['handler']['cache'] = new \Redis();            DB::$ref['handler']['cache']->connect( $options['config']['cache']['options']['host'] );            DB::$ref['handler']['cache']->select(  $options['config']['cache']['options']['database'] );          } catch(\RedisException $e) {            die('Could not connect to redis.');          }      }    }        return DB::$ref['config'];  }  // check the cache for a certain query, returning the result set if present  public function getCacheData( $query ) {    if( DB::$ref['config']['cache']['enabled'] ) {      switch( DB::$ref['config']['cache']['type'] ) {        case 'redis':          // cache is enabled and redis is the handler, lets check with redis for a hit on this query          if( ( $response = DB::$ref['handler']['cache']->get( $query ) ) !== false ) {            // hit found, return result            return json_decode( $response, true );          }          break;        default:          // invalid cache type/handler specified          return false;      }      die('yep');    }    return false; // no hit found or cache not initialized  }}class Handler {  private $fields;  private $filterFields;  private $primaryKey;  private $table;  private $orderField;    private $LOGICAL_OPERATORS = [ 'AND', 'OR', '&&', '||' ];  private $COMPARATORS = [ '>', '<', '>=', '<=', '=', 'LIKE', 'IN' ];  /**   * Required fields: array( 'primaryKey' => string, 'table' => string, 'fields' => array( string, ... ) )   */  function __construct( $options ) {    // check for db connection, and establish if not present    if( DB::$ref['handler']['sql'] === false ) {      try {        DB::$ref['handler']['sql'] = new \PDO( DB::$ref['config']['database']['type'].                                               ":host="  .DB::$ref['config']['database']['host'].                                               ";dbname=".DB::$ref['config']['database']['database'],                                               DB::$ref['config']['database']['username'],                                               DB::$ref['config']['database']['password'] );      } catch(PDOException $e) {        if( DEBUG ) {          echo $e->getMessage();        }        die('Could not connect to SQL database.');      }    }        $optType = gettype( $options );    if( $optType === 'string' ) {      // mapping definition not supplied, attempt to lookup in internal configuration      if( isset( DB::$ref['tables'][ $options ] ) ) {        $options = DB::$ref['tables'][ $options ];      } else {        return false; // mapping definition not found      }    } else if( $optType !== 'array' ) {      return false; // mapping definition not supplied, return error    }        $this->primaryKey = $options['primaryKey'];    $this->fields = $options['fields'];    $this->table = $options['table'];    if( !isset($options['orderField']) ) {      $this->orderField = $this->primaryKey;    } else {      $this->orderField = $options['orderField'];    }    $this->filterFields = $this->fields;    $this->filterFields[] = $this->primaryKey;  }  public function filter( $data, $filterFields = false ) {    if( $filterFields === false ) {      return array_intersect_key($data, array_flip( $this->fields ));    } else {      return array_intersect_key($data, array_flip( $this->filterFields ));    }  }    /**   * Return the name of the primary key   */  public function pkLookUp( $id ) {    return $this->primaryKey;  }  /**   * Grab the count using a filter set   */  public function getCount( $options = [ ] ) {    $whereClause = '';    $options = $this->filter( $options, true );    foreach( $options as $field => $value ) {      $whereClause .= (strlen($whereClause) ? ' AND ' : '')."{$field} = :{$field}";    }    if( strlen($whereClause) ) {      $whereClause = "WHERE {$whereClause}";    }        $query = "SELECT count({$this->primaryKey}) as count FROM {$this->table} {$whereClause}";    $prep = DB::$ref['handler']['sql']->prepare( $query );        if( $prep->execute( $options ) AND $prep->rowCount() ) {      $row = $prep->fetch();      return $row['count'];    } else {      return 0;    }  }  /**   * Grab the first item of a list   */  public function getOne( $options = [ ] ) {    $query = $this->formQuery( [ 'SELECT', [ '*' ] ], $options );    print_r( $query );        $prep = DB::$ref['handler']['sql']->prepare( $query['sql'] );    if( $prep->execute( $query['param'] ) AND $prep->rowCount() ) {      return $prep->fetchAll()[0];    } else {      return false;    }  }    public function formClause( $clause, $options = false ) {    $elCount = 0;    $next = false;    $subOptions = false;        if( empty( $options ) ) {      $options = [        'WHERE'      => '',        'param' => [ ]      ];    } else {      $subOptions = true;      $options['WHERE'] .= ' (';    }        foreach( $clause as $subKey => $subOption ) {      $optType = gettype( $subOption );      /*      print "[{$elCount}] [".gettype($subKey)."]:{$subKey} => [".gettype($subOption)."]:{$subOption}\n";      $q = [ 'WHERE' => [ 'someID' => 1, 'AND', 'somethingElse', '>', 2, 'OR', [ 'x' => 'y' ] ] ];      $elCount++;      */            switch( gettype( $subKey ) ) {        case 'integer':          if( empty( $next ) ) {            if( $optType === 'string' && in_array( $subOption, $this->LOGICAL_OPERATORS ) ) {              // AND/OR/etc              $options['WHERE'] .= " {$subOption}";            } else if( $optType === 'string' ) {              // assumption that this is a field name              $options['WHERE'] .= " {$subOption}";              $next = [ 'type' => OPERATOR, 'fieldName' => $subOption ];            } else if( $optType === 'array' ) {              $options = $this->formClause( $subOption, $options );            } else {              throw new \Exception("Unknown possible comparator: {$subOption}");            }          } else if( $next['type'] & OPERATOR ) {            if( $next['type'] & VALUE ) {              if( $optType === 'array' ) {                $options['WHERE'] .= " (";                $subList = '';                foreach( $subOption as $pNum => $piece ) {                  $subList .= (strlen($subList) ? ', ' : '').":{$next['fieldName']}_{$pNum}";                  $options['param'][ "{$next['fieldName']}_{$pNum}" ] = $piece;                }                $options['WHERE'] .= "{$subList})";              } else {                $options['WHERE'] .= " :{$next['fieldName']}";                $options['param'][ $next['fieldName'] ] = $subOption;              }              $next = false;            } else if( $optType === 'string' && in_array( $subOption, $this->COMPARATORS ) ) {              // this is a valid comparator, add it to the statement              $options['WHERE'] .= " {$subOption}";              $next['type'] |= VALUE;            } else {              throw new \Exception("Unknown possible comparator: {$subOption}");            }          }          break;                  case 'string':          if( empty( $next ) ) {            // direct value supplied            $options['param'][ $subKey ] = $subOption;            $options['WHERE'] .= "{$subKey} = :{$subKey}";          } else {            throw new \Exception("Expected direct value not found");          }          break;      }    }        if( $subOptions === true ) {      $options['WHERE'] .= ' )';    }        return $options;  }    public function formQuery( $queryMode = [ 'SELECT', [ '*' ] ], $opt = [ ] ) {    //$q = [ 'WHERE' => [ 'someID' => 1, 'AND', 'somethingElse', '>', 2, 'OR', [ 'x' => 'y' ] ] ];    // array containing named parameters and their corresponding values    $param = [ ];    $nextType = false; // variable which indicates the expected next value type    foreach( $opt as $key => $subOptions ) {      switch( $key ) {        // determine what operation or action is being performed        case 'WHERE':          // WHERE clause          if( is_array( $subOptions ) ) {            $options = $this->formClause( $subOptions );          } else {            throw new \Exception('Invalid WHERE clause supplied in query DSL.');          }          break;      }    }    switch( $queryMode[0] ) {      case 'SELECT':        return [ 'sql' => $queryMode[0] . ' ' . implode( $queryMode[1] ) . " FROM {$this->table} WHERE " . $options['WHERE'],                 'param' => $options['param'] ];        break;    }  }  /**   * Grab a list of records from the table   */  public function getList( $options = false, $limit = false ) {    $whereClause = '';    if( !empty( $options['where'] ) ) {      $options = $this->filter( $options, true );      foreach( $options as $field => $value ) {        $whereClause .= (strlen($whereClause) ? ' AND ' : '')."{$field} = :{$field}";      }    } else {      $options = array();    }    if( strlen($whereClause) ) {      $whereClause = 'WHERE '.$whereClause;    }    $query = "SELECT * FROM {$this->table} {$whereClause} ORDER BY {$this->orderField}";    if( !empty( $limit ) ) {      if( is_array( $limit ) ) {        $limitCount = count( $limit );        if( isset( $limit['offset'] ) || isset( $limit['count'] ) ) {          $query .= " LIMIT";          if( isset( $limit['offset'] ) ) {            $query .= " {$limit['offset']}, {$limit['count']}";          } else if( isset( $limit['count'] ) ) {            $query .= " {$limit['count']}";          }        } else if( $limitCount == 2 ) {          $query .= " LIMIT {$limit[0]} {$limit[1]}";        } else if( $limitCount == 1 ) {          $query .= " LIMIT {$limit[0]}";        }      } else if( $intLimit = intval($limit) ) {        $query .= " LIMIT {$intLimit}";      }    }    // Cache check    if( DB::$ref['config']['cache']['enabled'] ) {//      die('yep');    }    $prep = DB::$ref['handler']['sql']->prepare( $query );        if( $prep->execute( $options ) AND $prep->rowCount() ) {      return $prep->fetchAll();    } else {      return false;    }  }  public function delete( $id ) {    $query = "DELETE FROM {$this->table} WHERE {$this->primaryKey} = :{$this->primaryKey}";    $prep = DB::$ref['handler']['sql']->prepare( $query );    $params = array( $this->primaryKey => $id );    if( $prep->execute( $params ) ) {      return true;    }  }  /**   * Save a category   */  public function save( $fields, $id = false ) {    $insert = false;    $fields = $this->filter( $fields );    if( !$id ) {      $columns = '';      $params = '';      foreach ( $fields as $fieldName => $field ) {        $columns .= (strlen($columns) ? ',' : '')."{$fieldName}";        $params .= (strlen($params) ? ',' : '').":{$fieldName}";      }      $columns .= (strlen($columns) ? ',' : '').'insert_stamp';      $params .= (strlen($params) ? ',' : '').':insert_stamp';      $fields['insert_stamp'] = time();      $columns .= (strlen($columns) ? ',' : '').'update_stamp';      $params .= (strlen($params) ? ',' : '').':update_stamp';      $fields['update_stamp'] = time();      $query = "INSERT INTO {$this->table} ({$columns}) VALUES({$params})";      $prep = DB::$ref['handler']['sql']->prepare( $query );      $insert = true;    } else {      $fields['update_stamp'] = time();      foreach ( $fields as $fieldName => $field ) {        $set .= "{$fieldName} = :{$fieldName},";      }      $set = rtrim($set, ',');      $fields[ $this->primaryKey ] = $id;      $query = "UPDATE {$this->table} SET {$set} WHERE {$this->primaryKey} = :{$this->primaryKey}";      $prep = DB::$ref['handler']['sql']->prepare( $query );    }        if( $prep->execute( $fields ) ) {      if( $insert ) {        return DB::$ref['handler']['sql']->lastInsertId();      } else {        return $fields[ $this->primaryKey ];      }    }    return false;  }}?>